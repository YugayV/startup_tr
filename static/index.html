<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FX AI Analytics</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 0; padding: 20px; background-color: #f0f2f6; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { color: #0e1117; }
        .controls { margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px; display: flex; gap: 10px; align-items: center; }
        select, button { padding: 8px 12px; border-radius: 4px; border: 1px solid #ddd; font-size: 16px; }
        button { background-color: #ff4b4b; color: white; border: none; cursor: pointer; }
        button:hover { background-color: #ff2b2b; }
        #loading { display: none; color: #666; margin-left: 10px; }
        .grid { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; margin-top: 20px; }
        .chart-container { height: 500px; }
        .signal-card { background: #f8f9fa; padding: 15px; border-radius: 4px; font-family: monospace; white-space: pre-wrap; overflow-x: auto; font-size: 14px; }
        .recommendation { font-size: 1.2em; font-weight: bold; margin-bottom: 10px; padding: 10px; border-radius: 4px; text-align: center; }
        .rec-BUY { background-color: #d4edda; color: #155724; }
        .rec-SELL { background-color: #f8d7da; color: #721c24; }
        .rec-HOLD { background-color: #fff3cd; color: #856404; }
        .metric-box { display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="container">
        <h1>FX AI Analytics Dashboard</h1>
        
        <div class="controls">
            <label for="ticker">Instrument:</label>
            <select id="ticker">
                <option value="EURUSD=X" data-name="EUR/USD">EUR/USD</option>
                <option value="GBPUSD=X" data-name="GBP/USD">GBP/USD</option>
                <option value="USDJPY=X" data-name="USD/JPY">USD/JPY</option>
            </select>
            
            <label for="profile">Profile:</label>
            <select id="profile">
                <option value="">Default</option>
                <option value="aggressive">Aggressive</option>
                <option value="conservative">Conservative</option>
            </select>

            <button onclick="updateDashboard()">Analyze</button>
            <span id="loading">Loading data...</span>
        </div>

        <div id="recommendation-banner" class="recommendation"></div>

        <div class="grid">
            <div>
                <div id="mainChart" class="chart-container"></div>
                <div id="atrChart" class="chart-container" style="height: 300px; margin-top: 20px;"></div>
            </div>
            
            <div>
                <h3>Signal Details</h3>
                <div id="signalCard" class="signal-card">Select an instrument and click Analyze.</div>
                
                <h3>Metrics</h3>
                <div id="metricsBox" class="signal-card"></div>
            </div>
        </div>
    </div>

    <script>
        async function updateDashboard() {
            const tickerSelect = document.getElementById('ticker');
            const ticker = tickerSelect.value;
            const instrumentName = tickerSelect.options[tickerSelect.selectedIndex].getAttribute('data-name');
            const profile = document.getElementById('profile').value;
            
            document.getElementById('loading').style.display = 'inline';
            
            try {
                // 1. Get Prediction Signal
                const predictUrl = `/predict?ticker=${encodeURIComponent(ticker)}&instrument_name=${encodeURIComponent(instrumentName)}${profile ? `&profile=${profile}` : ''}`;
                const predictRes = await fetch(predictUrl);
                const predictData = await predictRes.json();
                
                // Render Signal Card
                document.getElementById('signalCard').textContent = JSON.stringify(predictData, null, 2);
                
                // Render Recommendation
                const action = predictData.signal.action;
                const recBanner = document.getElementById('recommendation-banner');
                recBanner.textContent = `Recommendation: ${action} (Score: ${predictData.signal.score.toFixed(2)})`;
                recBanner.className = `recommendation rec-${action}`;
                
                // Render Metrics
                document.getElementById('metricsBox').innerHTML = `
                    <div>Last Price: ${predictData.signal.last_price}</div>
                    <div>Target (7d): ${predictData.signal.target_price}</div>
                    <div>Exp. Return: ${(predictData.signal.expected_return * 100).toFixed(2)}%</div>
                    <div>ATR(14): ${predictData.signal.atr_14 || 'N/A'}</div>
                    <div>Volatility: ${predictData.signal.atr_level || 'N/A'}</div>
                `;

                // 2. Get Historical Data for Charts (New Endpoint)
                const historyUrl = `/history?ticker=${encodeURIComponent(ticker)}&interval=1d&years=2`;
                const historyRes = await fetch(historyUrl);
                if (historyRes.ok) {
                    const historyData = await historyRes.json();
                    renderCharts(historyData, predictData.signal, predictData.future_events || []);
                } else {
                    console.error("Failed to fetch history");
                    const mainChartEl = document.getElementById('mainChart');
                    if (mainChartEl) {
                        mainChartEl.textContent = 'Не удалось загрузить исторические данные для графика.';
                    }
                }

            } catch (err) {
                console.error(err);
                alert("Error fetching data: " + err.message);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        function renderCharts(data, signal, events) {
            if (typeof Plotly === 'undefined') {
                const mainChartEl = document.getElementById('mainChart');
                if (mainChartEl) {
                    mainChartEl.textContent = 'Не удалось загрузить библиотеку графиков (Plotly).';
                }
                return;
            }

            let forecastTrace = null;
            let lastDateStr = null;
            let lastClose = null;
            let forecastEndDate = null;
            try {
                const n = data.dates.length;
                if (n > 0 && signal && typeof signal.target_price === 'number') {
                    lastDateStr = data.dates[n - 1];
                    lastClose = data.close[n - 1];
                    const targetPrice = signal.target_price;
                    const steps = 7;

                    const addDaysISO = (dateStr, days) => {
                        const d = new Date(dateStr);
                        d.setDate(d.getDate() + days);
                        return d.toISOString().slice(0, 10);
                    };

                    const allDates = [lastDateStr];
                    const allPrices = [lastClose];
                    for (let i = 1; i <= steps; i++) {
                        const d = addDaysISO(lastDateStr, i);
                        const p = lastClose + (targetPrice - lastClose) * (i / steps);
                        allDates.push(d);
                        allPrices.push(p);
                        if (i === steps) {
                            forecastEndDate = d;
                        }
                    }

                    forecastTrace = {
                        x: allDates,
                        y: allPrices,
                        type: 'scatter',
                        mode: 'lines+markers',
                        line: {color: '#1f77b4', dash: 'dot'},
                        marker: {size: 6},
                        name: 'Прогноз цены (7 дней)'
                    };
                }
            } catch (e) {
                console.warn('Не удалось построить прогнозную линию:', e);
            }

            // Main Candlestick Chart
            const trace1 = {
                x: data.dates,
                close: data.close,
                decreasing: {line: {color: '#ff4b4b'}},
                high: data.high,
                increasing: {line: {color: '#00cc96'}},
                low: data.low,
                open: data.open,
                type: 'candlestick',
                xaxis: 'x',
                yaxis: 'y',
                name: 'Price'
            };

            const traces = [trace1];

            const firstDate = data.dates && data.dates.length > 0 ? data.dates[0] : null;
            const lastDateDefault = data.dates && data.dates.length > 0 ? data.dates[data.dates.length - 1] : null;
            const lastDateForLine = forecastEndDate || lastDateStr || lastDateDefault;

            if (lastClose !== null && firstDate && lastDateForLine) {
                traces.push({
                    x: [firstDate, lastDateForLine],
                    y: [lastClose, lastClose],
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#888888', dash: 'dash'},
                    name: 'Текущая цена'
                });
            }

            if (signal && typeof signal.support_level === 'number' && firstDate && lastDateForLine) {
                traces.push({
                    x: [firstDate, lastDateForLine],
                    y: [signal.support_level, signal.support_level],
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#2ca02c', dash: 'dot'},
                    name: 'Поддержка (20 дней)'
                });
            }

            if (signal && typeof signal.resistance_level === 'number' && firstDate && lastDateForLine) {
                traces.push({
                    x: [firstDate, lastDateForLine],
                    y: [signal.resistance_level, signal.resistance_level],
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#d62728', dash: 'dot'},
                    name: 'Сопротивление (20 дней)'
                });
            }

            if (forecastTrace) {
                traces.push(forecastTrace);
            }

            let shapes = [];
            try {
                if (Array.isArray(events) && events.length && data.dates && data.dates.length) {
                    const lowVals = data.low.filter(v => typeof v === 'number' && !isNaN(v));
                    const highVals = data.high.filter(v => typeof v === 'number' && !isNaN(v));
                    if (lowVals.length && highVals.length) {
                        const minPrice = Math.min(...lowVals);
                        const maxPrice = Math.max(...highVals);
                        const colorByImpact = (impact) => {
                            const imp = (impact || '').toString().toLowerCase();
                            if (imp.includes('high') || imp.includes('высок')) return '#d62728';
                            if (imp.includes('med') || imp.includes('средн')) return '#ff7f0e';
                            if (imp.includes('low') || imp.includes('низк')) return '#2ca02c';
                            return '#9467bd';
                        };
                        for (const ev of events) {
                            const t = ev.time || ev.date || ev.datetime;
                            if (!t) continue;
                            shapes.push({
                                type: 'line',
                                x0: t,
                                x1: t,
                                y0: minPrice,
                                y1: maxPrice,
                                xref: 'x',
                                yref: 'y',
                                line: {
                                    color: colorByImpact(ev.impact),
                                    width: 1,
                                    dash: 'dot'
                                }
                            });
                        }
                    }
                }
            } catch (e) {
                console.warn('Не удалось добавить вертикальные линии событий:', e);
            }

            const layout = {
                title: `Price History: ${document.getElementById('ticker').options[document.getElementById('ticker').selectedIndex].text}`,
                dragmode: 'zoom',
                showlegend: true,
                xaxis: { rangeslider: { visible: false } },
                shapes: shapes
            };
            
            Plotly.newPlot('mainChart', traces, layout);

            if (data.atr) {
                const atrValues = data.atr.filter(v => typeof v === 'number' && !isNaN(v));
                let qLow = null;
                let qHigh = null;
                if (atrValues.length > 0) {
                    const sorted = [...atrValues].sort((a, b) => a - b);
                    const quantile = (arr, q) => {
                        const pos = (arr.length - 1) * q;
                        const base = Math.floor(pos);
                        const rest = pos - base;
                        if (arr[base + 1] !== undefined) {
                            return arr[base] + rest * (arr[base + 1] - arr[base]);
                        } else {
                            return arr[base];
                        }
                    };
                    qLow = quantile(sorted, 0.33);
                    qHigh = quantile(sorted, 0.66);
                }

                const trace2 = {
                    x: data.dates,
                    y: data.atr,
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#ffa15a'},
                    name: 'ATR(14)'
                };

                const atrTraces = [trace2];

                if (qLow !== null) {
                    atrTraces.push({
                        x: data.dates,
                        y: new Array(data.dates.length).fill(qLow),
                        type: 'scatter',
                        mode: 'lines',
                        line: {color: '#2ca02c', dash: 'dot'},
                        name: 'ATR нижняя граница'
                    });
                }

                if (qHigh !== null) {
                    atrTraces.push({
                        x: data.dates,
                        y: new Array(data.dates.length).fill(qHigh),
                        type: 'scatter',
                        mode: 'lines',
                        line: {color: '#d62728', dash: 'dot'},
                        name: 'ATR верхняя граница'
                    });
                }
                
                const layout2 = {
                    title: 'Average True Range (14)',
                    xaxis: { title: 'Date' },
                    yaxis: { title: 'ATR' }
                };
                
                Plotly.newPlot('atrChart', atrTraces, layout2);
            }
        }
        
        // Initial load
        // updateDashboard(); 
    </script>
</body>
</html>
