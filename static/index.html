<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FX AI Analytics</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; margin: 0; padding: 20px; background-color: #0f172a; }
        .container { max-width: 1400px; margin: 0 auto; background: #0b1120; padding: 24px; border-radius: 16px; box-shadow: 0 20px 40px rgba(15,23,42,0.5); color: #e5e7eb; }
        h1 { color: #e5e7eb; margin-bottom: 8px; }
        .subtitle { color: #9ca3af; margin-bottom: 20px; font-size: 0.95rem; }
        .controls { margin-bottom: 20px; padding: 16px 18px; background: #020617; border-radius: 12px; display: flex; gap: 12px; align-items: center; border: 1px solid #1f2937; }
        select, button { padding: 8px 12px; border-radius: 4px; border: 1px solid #ddd; font-size: 16px; }
        select { background: #020617; color: #e5e7eb; border-color: #374151; }
        select:focus { outline: none; border-color: #60a5fa; box-shadow: 0 0 0 1px #60a5fa; }
        button { background: linear-gradient(90deg,#fb7185,#f97316); color: white; border: none; cursor: pointer; font-weight: 500; padding-inline: 18px; border-radius: 999px; }
        button:hover { background: linear-gradient(90deg,#f97316,#fb7185); }
        #loading { display: none; color: #9ca3af; margin-left: 10px; font-size: 0.9rem; }
        .grid { display: block; margin-top: 16px; }
        .chart-container { height: 520px; border-radius: 12px; background: #020617; border: 1px solid #1f2937; padding: 6px; }
        .signal-card { background: #020617; padding: 14px; border-radius: 10px; font-family: monospace; white-space: pre-wrap; overflow-x: auto; font-size: 13px; border: 1px solid #1f2937; color: #e5e7eb; }
        .recommendation { font-size: 1.1rem; font-weight: 600; margin-bottom: 14px; padding: 12px 14px; border-radius: 999px; text-align: center; border: 1px solid transparent; }
        .rec-BUY { background: rgba(16,185,129,0.1); color: #6ee7b7; border-color: rgba(16,185,129,0.4); }
        .rec-SELL { background: rgba(239,68,68,0.08); color: #fecaca; border-color: rgba(239,68,68,0.4); }
        .rec-HOLD { background: rgba(234,179,8,0.08); color: #facc15; border-color: rgba(234,179,8,0.4); }
        .metric-box { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.9rem; color: #d1d5db; }
        .bottom-panels { display: grid; grid-template-columns: 1.2fr 1fr; gap: 18px; margin-top: 24px; }
        .panel-title { margin: 0 0 8px 0; font-size: 1rem; color: #e5e7eb; }
        @media (max-width: 900px) {
            .bottom-panels { grid-template-columns: 1fr; }
            .chart-container { height: 420px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>FX AI Analytics Dashboard</h1>
        <div class="subtitle">AI-оценка FX с прогнозом на 7 дней, ATR и событийными уровнями.</div>
        
        <div class="controls">
            <label for="ticker">Instrument:</label>
            <select id="ticker">
                <option value="EURUSD=X" data-name="EUR/USD">EUR/USD</option>
                <option value="GBPUSD=X" data-name="GBP/USD">GBP/USD</option>
                <option value="USDJPY=X" data-name="USD/JPY">USD/JPY</option>
            </select>
            
            <label for="profile">Profile:</label>
            <select id="profile">
                <option value="">Default</option>
                <option value="aggressive">Aggressive</option>
                <option value="conservative">Conservative</option>
            </select>

            <button onclick="updateDashboard()">Analyze</button>
            <span id="loading">Loading data...</span>
        </div>

        <div id="recommendation-banner" class="recommendation"></div>

        <div class="grid">
            <div id="mainChart" class="chart-container"></div>
            <div id="atrChart" class="chart-container" style="height: 320px; margin-top: 20px;"></div>
        </div>

        <div class="bottom-panels">
            <div>
                <h3 class="panel-title">Signal Details</h3>
                <div id="signalCard" class="signal-card">Select an instrument and click Analyze.</div>
            </div>

            <div>
                <h3 class="panel-title">Metrics</h3>
                <div id="metricsBox" class="signal-card"></div>
            </div>
        </div>
    </div>

    <script>
        async function updateDashboard() {
            const tickerSelect = document.getElementById('ticker');
            const ticker = tickerSelect.value;
            const instrumentName = tickerSelect.options[tickerSelect.selectedIndex].getAttribute('data-name');
            const profile = document.getElementById('profile').value;
            
            document.getElementById('loading').style.display = 'inline';
            
            try {
                // 1. Get Prediction Signal
                const predictUrl = `/predict?ticker=${encodeURIComponent(ticker)}&instrument_name=${encodeURIComponent(instrumentName)}${profile ? `&profile=${profile}` : ''}`;
                const predictRes = await fetch(predictUrl);
                const predictData = await predictRes.json();
                
                // Render Signal Card
                document.getElementById('signalCard').textContent = JSON.stringify(predictData, null, 2);
                
                // Render Recommendation
                const action = predictData.signal.action;
                const recBanner = document.getElementById('recommendation-banner');
                recBanner.textContent = `Recommendation: ${action} (Score: ${predictData.signal.score.toFixed(2)})`;
                recBanner.className = `recommendation rec-${action}`;
                
                // Render Metrics
                document.getElementById('metricsBox').innerHTML = `
                    <div>Last Price: ${predictData.signal.last_price}</div>
                    <div>Target (7d): ${predictData.signal.target_price}</div>
                    <div>Exp. Return: ${(predictData.signal.expected_return * 100).toFixed(2)}%</div>
                    <div>ATR(14): ${predictData.signal.atr_14 || 'N/A'}</div>
                    <div>Volatility: ${predictData.signal.atr_level || 'N/A'}</div>
                `;

                // 2. Get Historical Data for Charts (New Endpoint)
                const historyUrl = `/history?ticker=${encodeURIComponent(ticker)}&interval=1d&years=2`;
                const historyRes = await fetch(historyUrl);
                if (historyRes.ok) {
                    const historyData = await historyRes.json();
                    renderCharts(historyData, predictData.signal, predictData.future_events || []);
                } else {
                    console.error("Failed to fetch history");
                    const mainChartEl = document.getElementById('mainChart');
                    if (mainChartEl) {
                        mainChartEl.textContent = 'Не удалось загрузить исторические данные для графика.';
                    }
                }

            } catch (err) {
                console.error(err);
                alert("Error fetching data: " + err.message);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        function renderCharts(data, signal, events) {
            if (typeof Plotly === 'undefined') {
                const mainChartEl = document.getElementById('mainChart');
                if (mainChartEl) {
                    mainChartEl.textContent = 'Не удалось загрузить библиотеку графиков (Plotly).';
                }
                return;
            }

            let forecastTrace = null;
            let lastDateStr = null;
            let lastClose = null;
            let forecastEndDate = null;
            let actionColor = '#60a5fa';
            let action = signal && signal.action ? String(signal.action).toUpperCase() : null;
            if (action === 'BUY') {
                actionColor = '#22c55e';
            } else if (action === 'SELL') {
                actionColor = '#ef4444';
            } else if (action === 'HOLD') {
                actionColor = '#facc15';
            }
            try {
                const n = data.dates.length;
                if (n > 0 && signal && typeof signal.target_price === 'number') {
                    lastDateStr = data.dates[n - 1];
                    lastClose = data.close[n - 1];
                    const targetPrice = signal.target_price;
                    const steps = 7;

                    const addDaysISO = (dateStr, days) => {
                        const d = new Date(dateStr);
                        d.setDate(d.getDate() + days);
                        return d.toISOString().slice(0, 10);
                    };

                    const allDates = [lastDateStr];
                    const allPrices = [lastClose];
                    for (let i = 1; i <= steps; i++) {
                        const d = addDaysISO(lastDateStr, i);
                        const p = lastClose + (targetPrice - lastClose) * (i / steps);
                        allDates.push(d);
                        allPrices.push(p);
                        if (i === steps) {
                            forecastEndDate = d;
                        }
                    }

                    forecastTrace = {
                        x: allDates,
                        y: allPrices,
                        type: 'scatter',
                        mode: 'lines+markers',
                        line: {color: actionColor, dash: 'dot'},
                        marker: {size: 6},
                        name: 'Прогноз цены (7 дней)'
                    };
                }
            } catch (e) {
                console.warn('Не удалось построить прогнозную линию:', e);
            }

            const traceRangeHigh = {
                x: data.dates,
                y: data.high,
                type: 'scatter',
                mode: 'lines',
                line: {color: '#4b5563', width: 1},
                name: 'Диапазон цены (High/Low)',
                hoverinfo: 'skip'
            };

            const traceRangeLow = {
                x: data.dates,
                y: data.low,
                type: 'scatter',
                mode: 'lines',
                line: {color: '#4b5563', width: 1},
                fill: 'tonexty',
                fillcolor: 'rgba(148, 163, 184, 0.18)',
                name: 'Диапазон цены (High/Low)',
                showlegend: false,
                hoverinfo: 'skip'
            };

            const traceClose = {
                x: data.dates,
                y: data.close,
                type: 'scatter',
                mode: 'lines',
                line: {color: '#e5e7eb', width: 1.6},
                name: 'Close'
            };

            const traces = [traceRangeHigh, traceRangeLow, traceClose];

            if (Array.isArray(data.ema_8)) {
                traces.push({
                    x: data.dates,
                    y: data.ema_8,
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#22c55e', width: 1.6},
                    name: 'EMA 8'
                });
            }

            if (Array.isArray(data.ema_21)) {
                traces.push({
                    x: data.dates,
                    y: data.ema_21,
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#38bdf8', width: 1.8},
                    name: 'EMA 21'
                });
            }

            if (Array.isArray(data.ema_55)) {
                traces.push({
                    x: data.dates,
                    y: data.ema_55,
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#a855f7', width: 1.6},
                    name: 'EMA 55'
                });
            }

            const firstDate = data.dates && data.dates.length > 0 ? data.dates[0] : null;
            const lastDateDefault = data.dates && data.dates.length > 0 ? data.dates[data.dates.length - 1] : null;
            const lastDateForLine = forecastEndDate || lastDateStr || lastDateDefault;

            if (lastClose !== null && firstDate && lastDateForLine) {
                traces.push({
                    x: [firstDate, lastDateForLine],
                    y: [lastClose, lastClose],
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#888888', dash: 'dash'},
                    name: 'Текущая цена'
                });
            }

            if (signal && typeof signal.support_level === 'number' && firstDate && lastDateForLine) {
                traces.push({
                    x: [firstDate, lastDateForLine],
                    y: [signal.support_level, signal.support_level],
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#16a34a', dash: 'dot'},
                    name: 'Поддержка (20 дней)'
                });
            }

            if (signal && typeof signal.resistance_level === 'number' && firstDate && lastDateForLine) {
                traces.push({
                    x: [firstDate, lastDateForLine],
                    y: [signal.resistance_level, signal.resistance_level],
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#dc2626', dash: 'dot'},
                    name: 'Сопротивление (20 дней)'
                });
            }

            if (forecastTrace) {
                traces.push(forecastTrace);
            }

            let shapes = [];
            try {
                if (Array.isArray(events) && events.length && data.dates && data.dates.length) {
                    const lowVals = data.low.filter(v => typeof v === 'number' && !isNaN(v));
                    const highVals = data.high.filter(v => typeof v === 'number' && !isNaN(v));
                    if (lowVals.length && highVals.length) {
                        const minPrice = Math.min(...lowVals);
                        const maxPrice = Math.max(...highVals);
                        const colorByImpact = (impact) => {
                            const imp = (impact || '').toString().toLowerCase();
                            if (imp.includes('high') || imp.includes('высок')) return '#d62728';
                            if (imp.includes('med') || imp.includes('средн')) return '#ff7f0e';
                            if (imp.includes('low') || imp.includes('низк')) return '#2ca02c';
                            return '#9467bd';
                        };
                        for (const ev of events) {
                            const t = ev.time || ev.date || ev.datetime;
                            if (!t) continue;
                            shapes.push({
                                type: 'line',
                                x0: t,
                                x1: t,
                                y0: minPrice,
                                y1: maxPrice,
                                xref: 'x',
                                yref: 'y',
                                line: {
                                    color: colorByImpact(ev.impact),
                                    width: 1,
                                    dash: 'dot'
                                }
                            });
                        }
                    }
                }
            } catch (e) {
                console.warn('Не удалось добавить вертикальные линии событий:', e);
            }

            const layout = {
                title: `Price History: ${document.getElementById('ticker').options[document.getElementById('ticker').selectedIndex].text}`,
                dragmode: 'zoom',
                showlegend: true,
                paper_bgcolor: '#020617',
                plot_bgcolor: '#020617',
                font: {color: '#e5e7eb'},
                xaxis: {
                    rangeslider: { visible: false },
                    gridcolor: '#1f2937',
                    zerolinecolor: '#1f2937',
                    linecolor: '#4b5563'
                },
                yaxis: {
                    gridcolor: '#1f2937',
                    zerolinecolor: '#1f2937',
                    linecolor: '#4b5563'
                },
                shapes: shapes
            };
            
            Plotly.newPlot('mainChart', traces, layout);

            if (data.atr) {
                const atrValues = data.atr.filter(v => typeof v === 'number' && !isNaN(v));
                let qLow = null;
                let qHigh = null;
                if (atrValues.length > 0) {
                    const sorted = [...atrValues].sort((a, b) => a - b);
                    const quantile = (arr, q) => {
                        const pos = (arr.length - 1) * q;
                        const base = Math.floor(pos);
                        const rest = pos - base;
                        if (arr[base + 1] !== undefined) {
                            return arr[base] + rest * (arr[base + 1] - arr[base]);
                        } else {
                            return arr[base];
                        }
                    };
                    qLow = quantile(sorted, 0.33);
                    qHigh = quantile(sorted, 0.66);
                }

                const trace2 = {
                    x: data.dates,
                    y: data.atr,
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#ffa15a'},
                    name: 'ATR(14)'
                };

                const atrTraces = [trace2];

                if (qLow !== null) {
                    atrTraces.push({
                        x: data.dates,
                        y: new Array(data.dates.length).fill(qLow),
                        type: 'scatter',
                        mode: 'lines',
                        line: {color: '#2ca02c', dash: 'dot'},
                        name: 'ATR нижняя граница'
                    });
                }

                if (qHigh !== null) {
                    atrTraces.push({
                        x: data.dates,
                        y: new Array(data.dates.length).fill(qHigh),
                        type: 'scatter',
                        mode: 'lines',
                        line: {color: '#d62728', dash: 'dot'},
                        name: 'ATR верхняя граница'
                    });
                }
                
                const layout2 = {
                    title: 'Average True Range (14)',
                    paper_bgcolor: '#020617',
                    plot_bgcolor: '#020617',
                    font: {color: '#e5e7eb'},
                    xaxis: { title: 'Date', gridcolor: '#1f2937', zerolinecolor: '#1f2937', linecolor: '#4b5563' },
                    yaxis: { title: 'ATR', gridcolor: '#1f2937', zerolinecolor: '#1f2937', linecolor: '#4b5563' }
                };
                
                Plotly.newPlot('atrChart', atrTraces, layout2);
            }
        }
        
        // Initial load
        // updateDashboard(); 
    </script>
</body>
</html>
